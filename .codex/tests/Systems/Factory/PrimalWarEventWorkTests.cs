using System.Collections.Generic;
using ProjectM;
using ProjectM.Shared.WarEvents;
using Unity.Transforms;
using Xunit;

namespace Bloodcraft.Tests.Systems.Factory;

public sealed class PrimalWarEventWorkTests
{
    [Fact]
    public void DescribeQuery_ReturnsGateCompositionWithIncludeDisabled()
    {
        var description = FactoryTestUtilities.DescribeQuery<PrimalWarEventWork>();

        Assert.Collection(
            description.All,
            requirement =>
            {
                Assert.Equal(typeof(WarEvent_ActiveGate), requirement.ElementType);
                Assert.Equal(ComponentAccessMode.ReadOnly, requirement.AccessMode);
            },
            requirement =>
            {
                Assert.Equal(typeof(WarEvent_ActiveUnit), requirement.ElementType);
                Assert.Equal(ComponentAccessMode.ReadOnly, requirement.AccessMode);
            });

        Assert.Empty(description.Any);
        Assert.Empty(description.None);
        Assert.Equal(EntityQueryOptions.IncludeDisabled, description.Options);
        Assert.True(description.RequireForUpdate);
    }

    [Fact]
    public void PortalQuery_DescribesPortalComposition()
    {
        var work = FactoryTestUtilities.CreateWork<PrimalWarEventWork>();
        var description = work.PortalQuery;

        Assert.Collection(
            description.All,
            requirement =>
            {
                Assert.Equal(typeof(WarEvent_ActivePortal), requirement.ElementType);
                Assert.Equal(ComponentAccessMode.ReadOnly, requirement.AccessMode);
            },
            requirement =>
            {
                Assert.Equal(typeof(WarEvent_ActiveUnit), requirement.ElementType);
                Assert.Equal(ComponentAccessMode.ReadOnly, requirement.AccessMode);
            });

        Assert.Equal(EntityQueryOptions.IncludeDisabled, description.Options);
        Assert.True(description.RequireForUpdate);
    }

    [Fact]
    public void OnCreate_RegistersRefreshActionsAndSurfacesCapacity()
    {
        var registrar = new RecordingRegistrar();
        var context = FactoryTestUtilities.CreateContext(registrar);
        var work = FactoryTestUtilities.CreateWork<PrimalWarEventWork>();

        FactoryTestUtilities.OnCreate(work, context);
        FactoryTestUtilities.OnUpdate(work, context);

        Assert.Equal(1, registrar.FacadeRegistrationCount);
        Assert.Equal(0, registrar.SystemRegistrationCount);

        registrar.InvokeRegistrations();

        Assert.Equal(1, registrar.EntityTypeHandleRequests);
        Assert.Equal(1, registrar.EntityStorageInfoLookupRequests);

        Assert.Collection(
            registrar.ComponentLookups,
            request =>
            {
                Assert.Equal(typeof(VBloodUnit), request.ElementType);
                Assert.True(request.IsReadOnly);
            },
            request =>
            {
                Assert.Equal(typeof(Translation), request.ElementType);
                Assert.True(request.IsReadOnly);
            });

        Assert.Collection(
            registrar.ComponentTypeHandles,
            request =>
            {
                Assert.Equal(typeof(WarEvent_ActiveGate), request.ElementType);
                Assert.True(request.IsReadOnly);
            },
            request =>
            {
                Assert.Equal(typeof(WarEvent_ActivePortal), request.ElementType);
                Assert.True(request.IsReadOnly);
            });

        Assert.Collection(
            registrar.BufferTypeHandles,
            request =>
            {
                Assert.Equal(typeof(WarEvent_ActiveUnit), request.ElementType);
                Assert.True(request.IsReadOnly);
            });

        Assert.Equal(PrimalWarEventWork.HandledEntitySetCapacity, 512);
    }

    [Fact]
    public void OnUpdate_InvokesGateAndPortalProcessors()
    {
        var gateHandles = new[] { new EntityHandle(1), new EntityHandle(2) };
        var portalHandles = new[] { new EntityHandle(10) };

        var processedGates = new List<EntityHandle>();
        var processedPortals = new List<EntityHandle>();

        var work = new PrimalWarEventWork(
            gateProcessor: processedGates.Add,
            portalProcessor: processedPortals.Add);

        var registrar = new RecordingRegistrar();
        var enumeratedQueries = new List<QueryDescription>();
        var gateQuery = FactoryTestUtilities.DescribeQuery<PrimalWarEventWork>();

        var context = FactoryTestUtilities.CreateContext(
            registrar,
            query: gateQuery,
            forEachEntity: (query, action) =>
            {
                enumeratedQueries.Add(query);

                if (query.Equals(gateQuery))
                {
                    foreach (var handle in gateHandles)
                    {
                        action(handle);
                    }
                }
                else if (query.Equals(work.PortalQuery))
                {
                    foreach (var handle in portalHandles)
                    {
                        action(handle);
                    }
                }
            });

        FactoryTestUtilities.OnUpdate(work, context);

        Assert.Equal(gateHandles, processedGates);
        Assert.Equal(portalHandles, processedPortals);
        Assert.Contains(gateQuery, enumeratedQueries);
        Assert.Contains(work.PortalQuery, enumeratedQueries);
    }

    [Fact]
    public void OnUpdate_SkipsPortalQueryWhenProcessorMissing()
    {
        var gateHandles = new[] { new EntityHandle(1) };
        var processedGates = new List<EntityHandle>();
        var work = new PrimalWarEventWork(processedGates.Add, portalProcessor: null);

        var registrar = new RecordingRegistrar();
        var enumeratedQueries = new List<QueryDescription>();
        var gateQuery = FactoryTestUtilities.DescribeQuery<PrimalWarEventWork>();

        var context = FactoryTestUtilities.CreateContext(
            registrar,
            query: gateQuery,
            forEachEntity: (query, action) =>
            {
                enumeratedQueries.Add(query);

                if (query.Equals(gateQuery))
                {
                    foreach (var handle in gateHandles)
                    {
                        action(handle);
                    }
                }
            });

        FactoryTestUtilities.OnUpdate(work, context);

        Assert.Equal(gateHandles, processedGates);
        Assert.Contains(gateQuery, enumeratedQueries);
        Assert.DoesNotContain(work.PortalQuery, enumeratedQueries);
    }
}
