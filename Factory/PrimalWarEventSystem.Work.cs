using System;
using Bloodcraft.Factory;
using Bloodcraft.Services;
using Bloodcraft.Utilities;
using ProjectM;
using ProjectM.Scripting;
using ProjectM.Shared.WarEvents;
using Unity.Collections;
using Unity.Entities;
using Unity.Transforms;

namespace Bloodcraft.Systems;

public partial class PrimalWarEventSystem
{
    public new sealed class Work : ISystemWork
    {
        static readonly QueryDescriptor PrimaryQueryDescriptor = QueryDescriptor.Create()
            .WithAll<WarEvent_ActiveGate>()
            .WithAll<WarEvent_ActiveUnit>()
            .IncludeDisabled();

        static readonly QueryDescriptor GateQueryDescriptor = QueryDescriptor.Create()
            .WithAll<WarEvent_ActiveGate>()
            .WithAll<WarEvent_ActiveUnit>()
            .IncludeDisabled()
            .RequireForUpdate();

        static readonly QueryDescriptor PortalQueryDescriptor = QueryDescriptor.Create()
            .WithAll<WarEvent_ActivePortal>()
            .WithAll<WarEvent_ActiveUnit>()
            .IncludeDisabled()
            .RequireForUpdate();

        readonly ISystemWork _implementation;
        readonly SystemWorkBuilder.QueryHandleHolder _primaryQuery;
        readonly SystemWorkBuilder.QueryHandleHolder _gateQuery;
        readonly SystemWorkBuilder.QueryHandleHolder _portalQuery;

        PrimalWarEventSystem _system;
        ServerGameManager _serverGameManager;

        readonly SystemWorkBuilder.ComponentLookupHandle<VBloodUnit> _vBloodLookup;
        readonly SystemWorkBuilder.ComponentLookupHandle<Translation> _translationLookup;

        readonly SystemWorkBuilder.ComponentTypeHandleHandle<WarEvent_ActiveGate> _gateHandle;
        readonly SystemWorkBuilder.ComponentTypeHandleHandle<WarEvent_ActivePortal> _portalHandle;
        readonly SystemWorkBuilder.BufferTypeHandleHandle<WarEvent_ActiveUnit> _unitBufferHandle;

        NativeParallelHashSet<Entity> _handled;
        readonly SystemWorkBuilder.NativeContainerHolder<NativeParallelHashMap<Entity, ActiveRift>> _activeRifts;

        internal NativeParallelHashMap<Entity, ActiveRift>.ReadOnly ActiveRiftsReadOnly =>
            _activeRifts.TryGetValue(out var activeRifts) && activeRifts.IsCreated
                ? activeRifts.AsReadOnly()
                : default;

        public Work()
        {
            var primaryDescriptor = PrimaryQueryDescriptor;

            var builder = new SystemWorkBuilder()
                .WithQuery(primaryDescriptor);

            _primaryQuery = builder.WithPrimaryQuery();

            var gateDescriptor = GateQueryDescriptor;
            _gateQuery = builder.WithQuery(ref gateDescriptor);

            var portalDescriptor = PortalQueryDescriptor;
            _portalQuery = builder.WithQuery(ref portalDescriptor);

            _vBloodLookup = builder.WithLookup<VBloodUnit>(isReadOnly: true);
            _translationLookup = builder.WithLookup<Translation>(isReadOnly: true);

            _gateHandle = builder.WithComponentTypeHandle<WarEvent_ActiveGate>(isReadOnly: true);
            _portalHandle = builder.WithComponentTypeHandle<WarEvent_ActivePortal>(isReadOnly: true);
            _unitBufferHandle = builder.WithBufferTypeHandle<WarEvent_ActiveUnit>(isReadOnly: true);

            _activeRifts = builder.WithNativeContainer(_ =>
                new NativeParallelHashMap<Entity, ActiveRift>(128, Allocator.Persistent));

            builder.OnCreate(context =>
            {
                _handled = new NativeParallelHashSet<Entity>(512, Allocator.Persistent);

                _system = (PrimalWarEventSystem)context.System;
                Instance = _system;
            });

            builder.OnStartRunning(context =>
            {
                _serverGameManager = context.System.World.GetExistingSystemManaged<ServerScriptMapper>().GetServerGameManager();

                if (!_isEdited)
                {
                    _isEdited = _system.TryModifyPrimalUnitCompositions(_serverGameManager);
                }
            });

            builder.OnUpdate(context =>
            {
                var primaryQuery = _primaryQuery.Handle;
                if (primaryQuery == null || primaryQuery.IsDisposed)
                {
                    return;
                }

                HandleActiveGates(context);
                HandleActivePortals(context);
                OnSweep(context);
            });

            builder.OnDestroy(context =>
            {
                if (_handled.IsCreated)
                {
                    _handled.Dispose();
                    _handled = default;
                }

                Instance = null;
                _nextRiftTime = double.MaxValue;
                _lastNotified = -1;
                _isEdited = false;

                _system = null;
                _serverGameManager = default;
            });

            _implementation = builder.Build();
        }

        public void Build(ref EntityQueryBuilder builder) =>
            _implementation.Build(ref builder);

        public void OnCreate(SystemContext context) =>
            _implementation.OnCreate(context);

        public void OnStartRunning(SystemContext context) =>
            _implementation.OnStartRunning(context);

        public void OnUpdate(SystemContext context) =>
            _implementation.OnUpdate(context);

        public void OnStopRunning(SystemContext context) =>
            _implementation.OnStopRunning(context);

        public void OnDestroy(SystemContext context) =>
            _implementation.OnDestroy(context);

        void HandleActiveGates(SystemContext context)
        {
            var gateQuery = _gateQuery.Handle;
            if (gateQuery == null || gateQuery.IsDisposed)
            {
                return;
            }

            var storageLookup = context.EntityStorageInfoLookup;
            var translationLookup = _translationLookup.Lookup;
            var vBloodLookup = _vBloodLookup.Lookup;

            try
            {
                SystemWorkBuilder.ForEachChunk(context, gateQuery)
                    .WithReadOnlyComponent(_gateHandle)
                    .WithBuffer(_unitBufferHandle)
                    .ForEach((chunkContext, gates, unitBuffers) =>
                    {
                        var activeRifts = _activeRifts.Container;
                        var entities = chunkContext.Entities;

                        for (int i = 0; i < chunkContext.Count; ++i)
                        {
                            WarEvent_ActiveGate activeGate = gates[i];
                            Entity entity = entities[i];

                            if (!activeGate.UnitComposition.Equals(_primalGate))
                                continue;

                            var buffer = unitBuffers[i];
                            bool isActive = false;

                            foreach (var activeUnit in buffer)
                            {
                                Entity unitEntity = activeUnit.Instance;
                                bool isGateBoss = vBloodLookup.HasComponent(unitEntity);

                                if (!storageLookup.Exists(unitEntity))
                                    continue;

                                if (_handled.Contains(unitEntity))
                                {
                                    isActive = true;
                                    continue;
                                }

                                Core.Delayed(() => unitEntity.TryApplyBuffWithLifeTimeNone(_variantBuffs.DrawRandom()));
                                ModifyPrimalUnit(unitEntity, isGateBoss);

                                isActive = true;
                                _handled.Add(unitEntity);
                            }

                            if (!isActive || !translationLookup.TryGetComponent(entity, out Translation translation))
                                continue;

                            if (!activeRifts.TryGetValue(entity, out ActiveRift activeRift))
                            {
                                activeRift = new(_system._riftHazards.DrawRandom(), _serverGameManager.ServerTime + Constants.RIFT_DURATION);
                                activeRifts.TryAdd(entity, activeRift);
                            }

                            if (isActive)
                            {
                                activeRift.Hazard.TrySpawnHazard(_serverGameManager, translation.Value);
                            }
                        }
                    });
            }
            catch (Exception e)
            {
                Core.Log.LogError($"[PrimalWarEventSystem.HandleActiveGates] Exception: {e}");
            }
        }

        void HandleActivePortals(SystemContext context)
        {
            var portalQuery = _portalQuery.Handle;
            if (portalQuery == null || portalQuery.IsDisposed)
            {
                return;
            }

            var storageLookup = context.EntityStorageInfoLookup;

            try
            {
                SystemWorkBuilder.ForEachChunk(context, portalQuery)
                    .WithReadOnlyComponent(_portalHandle)
                    .WithBuffer(_unitBufferHandle)
                    .ForEach((chunkContext, portals, unitBuffers) =>
                    {
                        var entities = chunkContext.Entities;

                        for (int i = 0; i < chunkContext.Count; ++i)
                        {
                            WarEvent_ActivePortal activePortal = portals[i];
                            Entity entity = entities[i];

                            if (!activePortal.UnitComposition.Equals(_primalPortal))
                                continue;

                            var buffer = unitBuffers[i];

                            foreach (var activeUnit in buffer)
                            {
                                Entity unitEntity = activeUnit.Instance;

                                if (!storageLookup.Exists(unitEntity))
                                    continue;
                                if (_handled.Contains(unitEntity))
                                    continue;

                                if (Misc.RollForChance(Constants.BUFF_CHANCE))
                                {
                                    Core.Delayed(() => unitEntity.TryApplyBuffWithLifeTimeNone(_variantBuffs.DrawRandom()));
                                }

                                ModifyPrimalUnit(unitEntity);
                                _handled.Add(unitEntity);
                            }
                        }
                    });
            }
            catch (Exception e)
            {
                Plugin.LogInstance.LogError($"[PrimalWarEventSystem.HandleActivePortals] Exception: {e}");
            }
        }

        void OnSweep(SystemContext context)
        {
            var storageLookup = context.EntityStorageInfoLookup;
            var units = _handled.ToNativeArray(Allocator.Temp);

            try
            {
                foreach (var unit in units)
                {
                    if (!storageLookup.Exists(unit))
                    {
                        _handled.Remove(unit);
                    }
                }
            }
            finally
            {
                if (units.IsCreated)
                {
                    units.Dispose();
                }
            }

            ref var activeRifts = ref _activeRifts.Container;
            var activeRiftPairs = activeRifts.GetKeyValueArrays(Allocator.Temp);

            try
            {
                var keys = activeRiftPairs.Keys;
                var values = activeRiftPairs.Values;

                for (int i = 0; i < activeRiftPairs.Length; ++i)
                {
                    if (_serverGameManager.ServerTime >= values[i].Lifetime)
                    {
                        activeRifts.Remove(keys[i]);
                    }
                }
            }
            finally
            {
                activeRiftPairs.Dispose();
            }
        }
    }
}
